dev.off()
load(file = "~/Desktop/Ariel-Final/Project-15/PHONEMeS/PHONEMeS/PHONEMeS_005_50%/resList_1.RData")
kk1 = resList[[1]][[1]]
kk2 = resList[[1]][[2]]
idx = c()
for(ii in 1:nrow(kk2)){if(length(intersect(x = which(kk1[,1]==kk2[ii,1]), y = which(kk1[,3]==kk2[ii,3])))==0){idx=c(idx,ii)}}
idx
kk2[idx, ]
rm(list = ls())
load(file = "~/Desktop/Ariel-Final/Project-15/PHONEMeS/PHONEMeS/PHONEMeS_005_50%/resList_1.RData")
kk1 = resList[[1]][[1]]
kk2 = resList[[1]][[2]]
idx = c()
for(ii in 1:nrow(kk2)){if(length(intersect(x = which(kk1[,1]==kk2[ii,1]), y = which(kk1[,3]==kk2[ii,3])))==0){idx=c(idx,ii)}}
idx
kk2[idx, ]
runif(n = 10, min = 1, max = 10000)
round(runif(n = 10, min = 1, max = 10000))
c(1690, 1467, 4237, 6188, 4752, 9308, 8693, 6533, 5186, 9726)
seeds = c(1690, 1467, 4237, 6188, 4752, 9308, 8693, 6533, 5186, 9726)
runif(n = 10, min = 1, max = 10000)
round(runif(n = 10, min = 1, max = 10000))
seeds = c(4651, 2361, 5206,  746, 5331, 8304, 6516, 5135, 9877, 9264)
library(CNORfeeder)
data(CNOlistDREAM,package="CellNOptR")
data(DreamModel,package="CellNOptR")
BTable <- makeBTables(CNOlist=CNOlistDREAM, k=2, measErr=c(0.1, 0))
BTable
Lrank <- linksRanking(CNOlist=CNOlistDREAM, measErr=c(0.1, 0), savefile=FALSE)
model<-preprocessing(data=CNOlistDREAM, model=DreamModel)
modelIntegr <- mapBTables2model(BTable=BTable,model=model,allInter=TRUE)
modelIntegr$reacID[modelIntegr$indexIntegr]
plotModel(model=modelIntegr, CNOlist=CNOlistDREAM, indexIntegr=modelIntegr$indexIntegr)
data(PPINigraph,package="CNORfeeder")
PPINigraph
PPINigraph[[1]]
PPINigraph[[2]]
PPINigraph[[3]]
PPINigraph[[4]]
PPINigraph[[5]]
PPINigraph[[6]]
?PPINigraph
data(UniprotIDdream,package="CNORfeeder")
modelIntegrWeight <- weighting(modelIntegr=modelIntegr, PKNmodel=DreamModel,
CNOlist=CNOlistDREAM, integrFac=10,
UniprotID=UniprotIDdream, PPI=PPINigraph)
library(devtools)
library(devtools)
devtools::install_github("davismcc/scater", build_vignettes = TRUE,ref = "RELEASE_3_6")
devtools::install_github("MarioniLab/scran", ref="RELEASE_3_6")
version
library(scater)
error = c(0.05, 0.1, 0.2)
pL = c(2, 3, 4, Inf)
penalty = c(1, 2, 5, 10, 50)
mm = matrix(data = , nrow = 1, ncol = 3)
for(ii in 1:length(error)){
for(jj in 1:length(pL)){
for(kk in 1:length(penalty)){
toBind = t(as.matrix(c(error[ii], pL[jj], penalty[kk])))
mm = rbind(mm, toBind)
}
}
}
mm = mm[-1, ]
nrow(mm)
error = c(0.05, 0.1, 0.2)
pL = c(2, 3, 4, Inf)
penalty = c(1, 2, 5, 10, 50, 100)
mm = matrix(data = , nrow = 1, ncol = 3)
for(ii in 1:length(error)){
for(jj in 1:length(pL)){
for(kk in 1:length(penalty)){
toBind = t(as.matrix(c(error[ii], pL[jj], penalty[kk])))
mm = rbind(mm, toBind)
}
}
}
mm = mm[-1, ]
nrow(mm)
error = c(0.05, 0.1, 0.2)
pL = c(2, 3, 4, Inf)
penalty = c(1, 2, 5, 10, 50)
mm = matrix(data = , nrow = 1, ncol = 3)
for(ii in 1:length(error)){
for(jj in 1:length(pL)){
for(kk in 1:length(penalty)){
toBind = t(as.matrix(c(error[ii], pL[jj], penalty[kk])))
mm = rbind(mm, toBind)
}
}
}
mm = mm[-1, ]
mm
error = c(0.05, 0.1, 0.2)
pL = c(1, 2, 3, 4, Inf)
penalty = c(1, 2, 5, 10, 50)
mm = matrix(data = , nrow = 1, ncol = 3)
for(ii in 1:length(error)){
for(jj in 1:length(pL)){
for(kk in 1:length(penalty)){
toBind = t(as.matrix(c(error[ii], pL[jj], penalty[kk])))
mm = rbind(mm, toBind)
}
}
}
mm = mm[-1, ]
nrow(mm)
getwd()
dev.off()
library(OmnipathR)
ptms = import_Omnipath_PTMS(filter_databases=c())
interactions = import_Omnipath_Interactions(filter_databases=c())
View(ptms)
View(interactions)
ss = c(ptms$sources, interactions$sources)
sources=c()
for(ii in 1:length(ss)){for(jj in 1:length(strsplit(x = ss, split = ";", fixed = TRUE)[[1]])){sources=unique(c(sources, strsplit(x = ss, split = ";", fixed = TRUE)[[1]][jj]))}}
ss
length(ss)
ss=unique(ss)
length(ss)
sources=c()
for(ii in 1:length(ss)){for(jj in 1:length(strsplit(x = ss, split = ";", fixed = TRUE)[[1]])){sources=unique(c(sources, strsplit(x = ss, split = ";", fixed = TRUE)[[1]][jj]))}}
length(sources)
sources
ii
for(ii in 1:length(ss)){for(jj in 1:length(strsplit(x = ss, split = ";", fixed = TRUE)[[1]])){sources=unique(c(sources, strsplit(x = ss, split = ";", fixed = TRUE)[[1]][jj]))}}
sources
sources=c()
for(ii in 1:length(ss)){for(jj in 1:length(strsplit(x = ss[ii], split = ";", fixed = TRUE)[[1]])){sources=unique(c(sources, strsplit(x = ss[ii], split = ";", fixed = TRUE)[[1]][jj]))}}
sources
length(sources)
load(file = "~/Documents/GitHub/Prostaglandin_Project/Background-Network/allD.RData")
View(allD)
length(which(allD$res=="R"))
library(CellNOptR)
?gaBinaryT1
library(CNORfeeder)
?plotModel
Anastasia Popova
library(CellNOptR)
?ilpBinaryT1
library(CNORfeeder)
getwd()
library(CellNOptR)
library(MEIGOR)
library(CNORode)
library(doParallel)
library(readr)
library(infotheo)
library(igraph)
# loading the toy example
data("ToyModel", package="CellNOptR")
data("CNOlistToy", package="CellNOptR")
model = ToyModel
cnolist = CNOlist(CNOlistToy)
# set initial parameters (here parameters 'k' and 'tau' are optimised and 'n' fixed to 3)
ode_parameters=createLBodeContPars(model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
## Parameter Optimization
# essm
paramsSSm=defaultParametersSSm()
paramsSSm$local_solver = "DHC"
paramsSSm$maxtime = 60;
paramsSSm$maxeval = Inf;
paramsSSm$atol=1e-6;
paramsSSm$reltol=1e-6;
paramsSSm$nan_fac=1000;
paramsSSm$dim_refset=30;
paramsSSm$n_diverse=1000;
paramsSSm$maxStepSize=Inf;
paramsSSm$maxNumSteps=10000;
paramsSSm$transfer_function = 4;
paramsSSm$lambda_tau=0.1
paramsSSm$lambda_k=0.01
paramsSSm$bootstrap=F
paramsSSm$SSpenalty_fac=0
paramsSSm$SScontrolPenalty_fac=0
## Training of the initial model
opt_pars=parEstimationLBode(cnolist, model, method="essm", ode_parameters=ode_parameters, paramsSSm=paramsSSm)
simData = plotLBodeFitness(cnolist = cnolist, model = model, ode_parameters = opt_pars, transfer_function = 4)
indices = identifyMisfitIndices(cnolist = cnolist, model = model, simData = simData, mseThresh = 0.05)
feederObject = buildFeederObjectDynamic(model = model, cnolist = cnolist, indices = indices, database = NULL, DDN = TRUE)
feederObject
integratedModel = integrateLinks(feederObject = feederObject, cnolist = cnolist, compression = FALSE, expansion = FALSE)
getwd()
rm(list = ls())
remove.packages("CNORfeeder")
getwd()
install.packages("~/Desktop/Feeder_Dev/CNORfeeder-master/", repos = NULL, type="source")
library(CellNOptR)
library(MEIGOR)
library(CNORode)
library(doParallel)
library(readr)
library(infotheo)
library(igraph)
# loading the toy example
data("ToyModel", package="CellNOptR")
data("CNOlistToy", package="CellNOptR")
model = ToyModel
cnolist = CNOlist(CNOlistToy)
# set initial parameters (here parameters 'k' and 'tau' are optimised and 'n' fixed to 3)
ode_parameters=createLBodeContPars(model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
## Parameter Optimization
# essm
paramsSSm=defaultParametersSSm()
paramsSSm$local_solver = "DHC"
paramsSSm$maxtime = 60;
paramsSSm$maxeval = Inf;
paramsSSm$atol=1e-6;
paramsSSm$reltol=1e-6;
paramsSSm$nan_fac=1000;
paramsSSm$dim_refset=30;
paramsSSm$n_diverse=1000;
paramsSSm$maxStepSize=Inf;
paramsSSm$maxNumSteps=10000;
paramsSSm$transfer_function = 4;
paramsSSm$lambda_tau=0.1
paramsSSm$lambda_k=0.01
paramsSSm$bootstrap=F
paramsSSm$SSpenalty_fac=0
paramsSSm$SScontrolPenalty_fac=0
## Training of the initial model
opt_pars=parEstimationLBode(cnolist, model, method="essm", ode_parameters=ode_parameters, paramsSSm=paramsSSm)
simData = plotLBodeFitness(cnolist = cnolist, model = model, ode_parameters = opt_pars, transfer_function = 4)
indices = identifyMisfitIndices(cnolist = cnolist, model = model, simData = simData, mseThresh = 0.05)
feederObject = buildFeederObjectDynamic(model = model, cnolist = cnolist, indices = indices)
feederObject
integratedModel = integrateLinks(feederObject = feederObject, cnolist = cnolist)
integratedModel = integrateLinks(feederObject = feederObject, cnolist = cnolist, expansion = TRUE)
integratedModel = integrateLinks(feederObject = feederObject, cnolist = cnolist)
integratedModel$model$reacID
integratedModel = integrateLinks(feederObject = feederObject, cnolist = cnolist, expansion = TRUE)
integratedModel$model$reacID
rm(list = ls())
remove.packages("CNORfeeder")
remove.packages("CNORfeeder")
library(devtools)
install_github('saezlab/CellNOpt-Feeder')
library(CellNOptR)
library(MEIGOR)
library(CNORode)
library(doParallel)
library(readr)
library(infotheo)
library(igraph)
# loading the toy example
data("ToyModel", package="CellNOptR")
data("CNOlistToy", package="CellNOptR")
model = ToyModel
cnolist = CNOlist(CNOlistToy)
# set initial parameters (here parameters 'k' and 'tau' are optimised and 'n' fixed to 3)
ode_parameters=createLBodeContPars(model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
## Parameter Optimization
# essm
paramsSSm=defaultParametersSSm()
paramsSSm$local_solver = "DHC"
paramsSSm$maxtime = 60;
paramsSSm$maxeval = Inf;
paramsSSm$atol=1e-6;
paramsSSm$reltol=1e-6;
paramsSSm$nan_fac=1000;
paramsSSm$dim_refset=30;
paramsSSm$n_diverse=1000;
paramsSSm$maxStepSize=Inf;
paramsSSm$maxNumSteps=10000;
paramsSSm$transfer_function = 4;
paramsSSm$lambda_tau=0.1
paramsSSm$lambda_k=0.01
paramsSSm$bootstrap=F
paramsSSm$SSpenalty_fac=0
paramsSSm$SScontrolPenalty_fac=0
## Training of the initial model
opt_pars=parEstimationLBode(cnolist, model, method="essm", ode_parameters=ode_parameters, paramsSSm=paramsSSm)
simData = plotLBodeFitness(cnolist = cnolist, model = model, ode_parameters = opt_pars, transfer_function = 4)
indices = identifyMisfitIndices(cnolist = cnolist, model = model, simData = simData, mseThresh = 0.05)
library(CNORfeeder)
indices = identifyMisfitIndices(cnolist = cnolist, model = model, simData = simData, mseThresh = 0.05)
feederObject = buildFeederObjectDynamic(model = model, cnolist = cnolist, indices = indices)
integratedModel = integrateLinks(feederObject = feederObject, cnolist = cnolist)
integratedModel$databaseWeight
plotModel(model = integratedModel$model, CNOlist = cnolist, indexIntegr = integratedModel$integLinksIdx)
ode_parameters=createLBodeContPars(integratedModel$model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
res = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, penFactor_k = 1000, paramsSSm = paramsSSm)
plotLBodeFitness(cnolist = res$CNOList, model = res$`Integrated-Model`$model, ode_parameters = res$Parameters, transfer_function = 4)
res = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, penFactor_k = 2, paramsSSm = paramsSSm)
dev.off()
getwd()
remove.packages("CNORfeeder")
library(devtools)
install_github('saezlab/CellNOpt-Feeder')
library(CellNOptR)
library(MEIGOR)
library(CNORode)
library(doParallel)
library(readr)
library(infotheo)
library(igraph)
library(CNORfeeder)
data("ToyModel", package="CellNOptR")
data("CNOlistToy", package="CellNOptR")
model = ToyModel
cnolist = CNOlist(CNOlistToy)
ode_parameters=createLBodeContPars(model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
## Parameter Optimization
# essm
paramsSSm=defaultParametersSSm()
paramsSSm$local_solver = "DHC"
paramsSSm$maxtime = 60;
paramsSSm$maxeval = Inf;
paramsSSm$atol=1e-6;
paramsSSm$reltol=1e-6;
paramsSSm$nan_fac=1000;
paramsSSm$dim_refset=30;
paramsSSm$n_diverse=1000;
paramsSSm$maxStepSize=Inf;
paramsSSm$maxNumSteps=10000;
paramsSSm$transfer_function = 4;
paramsSSm$lambda_tau=0.1
paramsSSm$lambda_k=0.01
paramsSSm$bootstrap=F
paramsSSm$SSpenalty_fac=0
paramsSSm$SScontrolPenalty_fac=0
opt_pars=parEstimationLBode(cnolist, model, method="essm", ode_parameters=ode_parameters, paramsSSm=paramsSSm)
simData = plotLBodeFitness(cnolist = cnolist, model = model, ode_parameters = opt_pars, transfer_function = 4)
indices = identifyMisfitIndices(cnolist = cnolist, model = model, simData = simData, mseThresh = 0.05)
feederObject = buildFeederObjectDynamic(model = model, cnolist = cnolist, indices = indices, database = NULL, DDN = TRUE)
integratedModel = integrateLinks(feederObject = feederObject, cnolist = cnolist)
plotModel(model = integratedModel$model, CNOlist = cnolist, indexIntegr = integratedModel$integLinksIdx)
ode_parameters=createLBodeContPars(integratedModel$model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
dev.off()
res1 = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 2)
plotLBodeFitness(cnolist = res1$CNOList, model = res1$`Integrated-Model`$model, ode_parameters = res1$Parameters, transfer_function = 4)
dev.off()
res2 = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 100)
plotLBodeFitness(cnolist = res2$CNOList, model = res2$`Integrated-Model`$model, ode_parameters = res2$Parameters, transfer_function = 4)
res2 = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 1000)
plotLBodeFitness(cnolist = res2$CNOList, model = res2$`Integrated-Model`$model, ode_parameters = res2$Parameters, transfer_function = 4)
integratedModel$model$reacID
integratedModel$databaseWeight
res2 = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, paramsSSm = paramsSSm, penFactor_k = 100)
plotLBodeFitness(cnolist = res2$CNOList, model = res2$`Integrated-Model`$model, ode_parameters = res2$Parameters, transfer_function = 4)
rm(res2)
dev.off()
res2 = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, penFactor_k = 100, paramsSSm = paramsSSm)
plotLBodeFitness(cnolist = res2$CNOList, model = res2$`Integrated-Model`$model, ode_parameters = res2$Parameters, transfer_function = 4)
res2 = runDynamicFeeder(cnolist = cnolist, integratedModel = integratedModel, ode_parameters = ode_parameters, penFactor_k = 10000, paramsSSm = paramsSSm)
plotLBodeFitness(cnolist = res2$CNOList, model = res2$`Integrated-Model`$model, ode_parameters = res2$Parameters, transfer_function = 4)
rm(list = ls())
library(CARNIVAL) # load CARNIVAL library
#Load files
file.copy(from=system.file(“SBV_EGF_tvalues.csv”,package=“CARNIVAL”),to=getwd(),overwrite=TRUE)
file.copy(from=system.file(“dorothea_TF_mapping.csv”,package=“CARNIVAL”),to=getwd(),overwrite=TRUE)
load(file = system.file(“BEST_viperRegulon.rdata”,package=“CARNIVAL”))
df<-read.csv2(“SBV_EGF_tvalues.csv”, row.names = ‘GeneName’)
map<-read.csv(“dorothea_TF_mapping.csv”)
#Run DoRothEA and convert from gene symbol to uniprot ID
TF_genesymbol<-runDoRothEA(df, regulon=viper_regulon, confidence_level=c(‘A’,‘B’,‘C’))
library(CARNIVAL) # load CARNIVAL library
#Load files
file.copy(from=system.file("SBV_EGF_tvalues.csv",package="CARNIVAL"),to=getwd(),overwrite=TRUE)
file.copy(from=system.file("BEST_viperRegulon.rdata",package="CARNIVAL"),to=getwd(),overwrite=TRUE)
load(file = system.file("BEST_viperRegulon.rdata",package="CARNIVAL"))
df<-read.csv2("SBV_EGF_tvalues.csv", row.names = 'GeneName')
map<-read.csv("dorothea_TF_mapping.csv")
#Run DoRothEA and convert from gene symbol to uniprot ID
TF_genesymbol<-runDoRothEA(df, regulon=viper_regulon, confidence_level=c('A','B','C'))
library(CARNIVAL) # load CARNIVAL library
#Load files
file.copy(from=system.file("SBV_EGF_tvalues.csv",package="CARNIVAL"),to=getwd(),overwrite=TRUE)
file.copy(from=system.file("BEST_viperRegulon.rdata",package="CARNIVAL"),to=getwd(),overwrite=TRUE)
load(file = system.file("BEST_viperRegulon.rdata",package="CARNIVAL"))
df<-read.csv2("SBV_EGF_tvalues.csv", row.names = 'GeneName')
map<-read.csv("dorothea_TF_mapping.csv")
#Run DoRothEA and convert from gene symbol to uniprot ID
TF_genesymbol<-runDoRothEA(df, regulon=viper_regulon, confidence_level=c('A','B','C'))
TF_genesymbol
sessionInfo()
rm(list)
rm(list = ls())
library(CellNOptR)
data("ToyModel", package="CellNOptR")
data("CNOlistToy", package="CellNOptR")
pknmodel = ToyModel
cnolist = CNOlist(CNOlistToy)
model = preprocessing(cnolist, pknmodel)
resILP = ilpBinaryT1(cnolist = cnolist, model = model, numSolutions = 5)
library(readr)
resILP = ilpBinaryT1(cnolist = cnolist, model = model, numSolutions = 5)
library(stringr)
resILP = ilpBinaryT1(cnolist = cnolist, model = model, numSolutions = 5)
resILP
resILP = ilpBinaryT1(cnolist = cnolist, model = model, numSolutions = 3)
resILP$bitstringILP
cutAndPlot(CNOlist = cnolist, model = model, bStrings = resILP$bitstringILP[[1]])
cutAndPlot(CNOlist = cnolist, model = model, bStrings = list(resILP$bitstringILP[[1]]))
res = gaBinaryT1(cnolist, model, verbose=FALSE)
plotModel(model = model, CNOlist = cnolist)
cutAndPlot(cnolist, model, list(res$bString))
cutAndPlot(CNOlist = cnolist, model = model, bStrings = list(resILP$bitstringILP[[1]]))
cutAndPlot(CNOlist = cnolist, model = model, bStrings = list(resILP$bitstringILP[[2]]))
cutAndPlot(CNOlist = cnolist, model = model, bStrings = list(resILP$bitstringILP[[3]]))
dev.off()
vignette("CellNOptR")
vignette()
vignette("01-Working_with_large_arrays")
vignette("CellNOptR")
vignette("CellNOptR")
vignette(CellNOptR)
library(Biobase)
openVignette(package = "CellNOptR")
installed.packages(knitr)
install.packages('knitr', dependencies = TRUE)
library(knitr)
knit2pdf(input = "~/Documents/vignettes/CNORfeeder-vignette.Rnw", output = "~/Documents/vignettes/CNORfeeder-vignette.pdf")
rm(list = ls())
library(CellNOptR)
library(MEIGOR)
library(CNORode)
library(doParallel)
library(readr)
library(infotheo)
library(igraph)
library(CNORfeeder)
data("ToyModel", package="CellNOptR")
data("CNOlistToy", package="CellNOptR")
model = ToyModel
cnolist = CNOlist(CNOlistToy)
ode_parameters=createLBodeContPars(model, LB_n = 1, LB_k = 0,
LB_tau = 0, UB_n = 3, UB_k = 1, UB_tau = 1, default_n = 3,
default_k = 0.5, default_tau = 0.01, opt_n = FALSE, opt_k = TRUE,
opt_tau = TRUE, random = TRUE)
## Parameter Optimization
# essm
paramsSSm=defaultParametersSSm()
paramsSSm$local_solver = "DHC"
paramsSSm$maxtime = 60;
paramsSSm$maxeval = Inf;
paramsSSm$atol=1e-6;
paramsSSm$reltol=1e-6;
paramsSSm$nan_fac=1000;
paramsSSm$dim_refset=30;
paramsSSm$n_diverse=1000;
paramsSSm$maxStepSize=Inf;
paramsSSm$maxNumSteps=10000;
paramsSSm$transfer_function = 4;
paramsSSm$lambda_tau=0.1
paramsSSm$lambda_k=0.01
paramsSSm$bootstrap=F
paramsSSm$SSpenalty_fac=0
paramsSSm$SScontrolPenalty_fac=0
opt_pars=parEstimationLBode(cnolist, model, method="essm", ode_parameters=ode_parameters, paramsSSm=paramsSSm)
simData = plotLBodeFitness(cnolist = cnolist, model = model, ode_parameters = opt_pars, transfer_function = 4)
indices = identifyMisfitIndices(cnolist = cnolist, model = model, simData = simData, mseThresh = 0.05)
View(buildFeederObjectDynamic)
database = NULL
DDN = TRUE
pathLength = 3
k = 2
measErr = c(0.1,
0)
if (is.null(database) && DDN == FALSE) {
stop("You should either allow data-driven inference or make use of a database of interactions or both in order to integrate the new links in the PKN!")
}
indMeas = unique(names(indices$indices))
BTable <- makeBTables(CNOlist = cnolist, k = k, measErr = measErr)
BTable
View(makeBTables)
cnolist@timepoints
BTable <- makeBTables(CNOlist = cnolist, k = k, measErr = measErr, timePoint = 10)
BTable
rm(list = ls())
remove.packages(CNORfeeder)
remove.packages("CNORfeeder")
library(devtools)
install_github('saezlab/CellNOpt-Feeder')
library(CellNOptR)
library(MEIGOR)
library(CNORode)
library(doParallel)
library(readr)
library(infotheo)
library(igraph)
library(CNORfeeder)
data("ToyModel", package="CellNOptR")
data("CNOlistToy", package="CellNOptR")
model = ToyModel
cnolist = CNOlist(CNOlistToy)
cnolist@cues
vignette("CellNOptR-vignette")
setwd("~/Documents/GitHub/CellNOptR/vignettes/")
library(CellNOptR)
?ilpBinaryT1
